from __future__ import annotations

import argparse
import os
import re
import time
from dataclasses import dataclass, field, asdict
from datetime import datetime
from typing import Any, List, Dict, Optional

from bs4 import BeautifulSoup
from bs4.element import Tag, NavigableString
from pptx import Presentation
from pptx.dml.color import RGBColor
from pptx.enum.shapes import MSO_SHAPE
from pptx.enum.text import PP_ALIGN, MSO_AUTO_SIZE
from pptx.util import Inches, Pt

# Import custom parsers
from parsers import parse_message_center_html, parse_roadmap_html

# Constants & theme
EMU_PER_INCH = 914400
DEFAULT_RAIL_WIDTH_IN = 3.5
PAGE_MARGIN_IN = 0.6

# Colors
GOLD = RGBColor(212, 175, 55)
WHITE = RGBColor(255, 255, 255)
BLACK = RGBColor(0, 0, 0)
DARK_PURPLE = RGBColor(40, 17, 63)
MID_PURPLE = RGBColor(70, 35, 100)

# Utility functions
def emu_to_inches(x: int | float | None) -> float:
    return (float(x) / EMU_PER_INCH) if x is not None else 0.0

def inches_to_emu(x: float | int | None) -> int:
    return int(round(float(x) * EMU_PER_INCH)) if x is not None else 0

def _txt(x: Any) -> str:
    try:
        return x.get_text(strip=True)  # type: ignore[attr-defined]
    except Exception:
        return "" if x is None else str(x)

def _attr(x: Any, name: str) -> str:
    try:
        v = x.get(name)
        if v is None:
            return ""
        if isinstance(v, str):
            return v
        try:
            return " ".join(v)
        except Exception:
            return str(v)
    except Exception:
        return ""

def first(el: Any, css: str) -> Any:
    try:
        return el.select_one(css)  # type: ignore[attr-defined]
    except Exception:
        return None

def all_of(el: Any, css: str) -> List[Any]:
    try:
        res = el.select(css)  # type: ignore[attr-defined]
        return list(res) if res else []
    except Exception:
        return []

    # normalize string fields
    for k in ("title", "summary", "url", "roadmap_id", "status", "month"):
        v = data.get(k)
        data[k] = "" if v is None else str(v)

    # normalize list-ish fields
    list_fields = ("products", "platforms", "audience", "phases", "clouds")
    for k in list_fields:
        v = data.get(k)
        if v is None:
            data[k] = []
        elif isinstance(v, (list, tuple, set)):
            data[k] = [str(x) for x in v if x is not None]
        else:
            data[k] = [str(v)]

    # optional date fields as strings
    for k in ("created", "modified", "ga"):
        v = data.get(k)
        if v is None:
            data[k] = ""
        else:
            data[k] = str(v)

    return Item(**data)

def _to_text(val: Any) -> str:
    if val is None:
        return ""
    if isinstance(val, NavigableString):
        return str(val)
    if isinstance(val, Tag):
        return val.get_text(" ", strip=True)
    from collections.abc import Sequence
    if isinstance(val, Sequence) and not isinstance(val, (str, bytes, bytearray)):
        return ", ".join(_to_text(v) for v in val if v is not None)
    return str(val)

def _inches(x: Optional[float]) -> int:
    return inches_to_emu(x)

def _pt(x: Optional[float]) -> int:
    return Pt(0 if x is None else float(x))

def safe_find(node, name, **kwargs):
    if not isinstance(node, Tag):
        return None
    try:
        return node.find(name, **kwargs)
    except Exception:
        return None

def safe_find_all(node, name, **kwargs):
    if not isinstance(node, Tag):
        return []
    try:
        return [t for t in node.find_all(name, **kwargs) if isinstance(t, Tag)]
    except Exception:
        return []


def add_title_box(
    slide,
    text: str,
    *,
    left_in: float,
    top_in: float,
    width_in: float,
    height_in: float,
    font_size_pt: int = 60,
    bold: bool = True,
    color: RGBColor = GOLD,
    align=PP_ALIGN.LEFT,
):
    """Title that wraps & shrinks to fit."""
    box = slide.shapes.add_textbox(
        _inches(left_in), _inches(top_in), _inches(width_in), _inches(height_in)
    )
    tf = box.text_frame
    tf.clear()
    tf.word_wrap = True
    tf.auto_size = MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE
    tf.margin_left = _inches(0.05)
    tf.margin_right = _inches(0.05)
    tf.margin_top = _inches(0.02)
    tf.margin_bottom = _inches(0.02)
    p = tf.paragraphs[0]
    p.alignment = align
    r = p.add_run()
    r.text = text or ""
    f = r.font
    f.size = Pt(font_size_pt)
    f.bold = bold
    f.color.rgb = color
    return box


def add_picture_safe(slide, image_path: str | None, left_in: float, top_in: float, width_in: float | None = None, height_in: float | None = None):
    if not image_path or not os.path.exists(image_path):
        return None
    try:
        left = inches_to_emu(left_in)
        top = inches_to_emu(top_in)
        width = inches_to_emu(width_in) if width_in is not None else None
        height = inches_to_emu(height_in) if height_in is not None else None
        if width is None and height is None:
            return slide.shapes.add_picture(image_path, left, top)
        elif width is not None and height is None:
            return slide.shapes.add_picture(image_path, left, top, width=width)
        elif width is None and height is not None:
            return slide.shapes.add_picture(image_path, left, top, height=height)
        else:
            return slide.shapes.add_picture(image_path, left, top, width=width, height=height)
    except Exception as e:
        print(f"Error adding picture {image_path}: {e}")
        return None

# Add a textbox with styling
def add_text_box(slide, text: str, *, left_in: float, top_in: float, width_in: float, height_in: float,
                 font_size_pt: int = 18, bold: bool = False, color: RGBColor = WHITE, align=PP_ALIGN.LEFT):
    textbox = slide.shapes.add_textbox(inches_to_emu(left_in), inches_to_emu(top_in), inches_to_emu(width_in), inches_to_emu(height_in))
    tf = textbox.text_frame
    tf.clear()
    tf.word_wrap = True
    tf.auto_size = MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE
    tf.margin_left = inches_to_emu(0.05)
    tf.margin_right = inches_to_emu(0.05)
    tf.margin_top = inches_to_emu(0.02)
    tf.margin_bottom = inches_to_emu(0.02)
    p = tf.paragraphs[0]
    p.alignment = align
    r = p.add_run()
    r.text = text or ""
    r.font.size = Pt(font_size_pt)
    r.font.bold = bold
    r.font.color.rgb = color
    return textbox



# Add background image stretched to full slide
def add_full_slide_picture(slide, prs, image_path: str | None):
    if not image_path or not os.path.exists(image_path):
        return
    width_in = emu_to_inches(prs.slide_width)
    height_in = emu_to_inches(prs.slide_height)
    add_picture_safe(slide, image_path, 0, 0, width_in, height_in)

# Draw vertical side rail
def draw_side_rail(slide, prs, rail_left_in: float, rail_width_in: float, color: RGBColor = DARK_PURPLE):
    slide_h_in = emu_to_inches(prs.slide_height)
    shape = slide.shapes.add_shape(
        MSO_SHAPE.RECTANGLE,
        inches_to_emu(rail_left_in),
        0,
        inches_to_emu(rail_width_in),
        inches_to_emu(slide_h_in),
    )
    fill = shape.fill
    fill.solid()
    fill.fore_color.rgb = color
    shape.line.fill.background()
    return shape

def add_bubble(slide, text: str, left_in: float, top_in: float, width_in: float, height_in: float):
    shape = slide.shapes.add_shape(
        MSO_SHAPE.ROUNDED_RECTANGLE,
        inches_to_emu(left_in),
        inches_to_emu(top_in),
        inches_to_emu(width_in),
        inches_to_emu(height_in),
    )
    fill = shape.fill
    fill.solid()
    fill.fore_color.rgb = MID_PURPLE
    shape.line.fill.background()
    tf = shape.text_frame
    tf.clear()
    tf.word_wrap = True
    p = tf.paragraphs[0]
    p.alignment = PP_ALIGN.LEFT
    r = p.add_run()
    r.text = text
    f = r.font
    f.size = Pt(16)
    f.bold = True
    f.color.rgb = WHITE
    return shape


def add_notes(slide, text: str):
    if not text:
        return
    notes = slide.notes_slide.notes_text_frame
    if notes.paragraphs and notes.paragraphs[0].text:
        notes.text += "\n\n" + text
    else:
        notes.text = text


def _safe_save(prs, output_path: str, tries: int = 4, delay_sec: float = 0.6) -> str:
    base, ext = os.path.splitext(output_path)
    for i in range(tries):
        candidate = (
            output_path if i == 0 else f"{base}_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{i}{ext}"
        )
        try:
            prs.save(candidate)
            return candidate
        except PermissionError:
            time.sleep(delay_sec)
            continue
    # Final attempt
    prs.save(output_path)
    return output_path


# =========================
# Data models and parsing helpers
# =========================

# Core Item dataclass
@dataclass
class Item:
    title: str = ""
    summary: str = ""
    description: str = ""
    roadmap_id: str = ""
    url: str = ""
    month: str = ""
    product: str = ""
    products: List[str] = field(default_factory=list)
    platforms: List[str] = field(default_factory=list)
    audience: List[str] = field(default_factory=list)
    clouds: List[str] = field(default_factory=list)
    status: str = ""
    phases: str = ""
    created: str = ""
    modified: str = ""
    ga: str = ""


# Helper to create Item from dict
def _to_item(d: dict[str, Any]) -> Item:
    return Item(
        title=str(d.get("title", "")),
        summary=str(d.get("summary", "")),
        description=str(d.get("description", "")),
        roadmap_id=str(d.get("roadmap_id", "")),
        url=str(d.get("url", "")),
        month=str(d.get("month", "")),
        product=str(d.get("product", "")),
        products=list(d.get("products", [])),
        platforms=list(d.get("platforms", [])),
        audience=list(d.get("audience", [])),
        clouds=list(d.get("clouds", [])),
        status=str(d.get("status", "")),
        phases=str(d.get("phases", "")),
        created=str(d.get("created", "")),
        modified=str(d.get("modified", "")),
        ga=str(d.get("ga", "")),
    )


# ----------------------------
# Slide builders
# ----------------------------

def add_cover_slide(prs, assets, cover_title, cover_dates, logo1_path, logo2_path):
    slide = prs.slides.add_slide(prs.slide_layouts[6])  # blank layout
    add_full_slide_picture(slide, prs, assets.get("cover"))
    # Add title text
    add_title_box(
        slide,
        cover_title or "Title",
        left_in=PAGE_MARGIN_IN,
        top_in=2,
        width_in=10,
        height_in=2,
        font_size_pt=52,
        color=GOLD,
        align=PP_ALIGN.CENTER,
    )
    # Add dates
    if cover_dates:
        add_text_box(
            slide,
            cover_dates,
            left_in=PAGE_MARGIN_IN,
            top_in=4,
            width_in=10,
            height_in=1,
            font_size_pt=30,
            color=WHITE,
            align=PP_ALIGN.CENTER,
        )
    # Add logos
    if logo1_path:
        add_picture_safe(slide, logo1_path, left_in=0.4, top_in=6.6, height_in=0.6)
    if logo2_path:
        add_picture_safe(slide, logo2_path, left_in=9, top_in=6.6, height_in=0.6)

def add_agenda_slide(prs, assets, agenda_lines=None):
    slide = prs.slides.add_slide(prs.slide_layouts[6])  # blank layout
    add_full_slide_picture(slide, prs, assets.get("agenda"))
    sw_in = emu_to_inches(prs.slide_width)
    # Title
    add_title_box(
        slide,
        "Agenda",
        left_in=PAGE_MARGIN_IN,
        top_in=0.9,
        width_in=sw_in - 2 * PAGE_MARGIN_IN,
        height_in=1.2,
        font_size_pt=52,
        color=GOLD,
        align=PP_ALIGN.LEFT,
    )
    # List agenda items
    if not agenda_lines:
        agenda_lines = ["Overview", "Key updates by product", "Timeline & rollout status", "Q&A"]
    top = 2.4
    for line in agenda_lines:
        add_text_box(
            slide,
            f"• {line}",
            left_in=PAGE_MARGIN_IN,
            top_in=top,
            width_in=sw_in - 2 * PAGE_MARGIN_IN,
            height_in=0.5,
            font_size_pt=26,
            color=WHITE,
        )
        top += 0.6

def add_separator_slide(prs, assets, title):
    slide = prs.slides.add_slide(prs.slide_layouts[6])
    add_full_slide_picture(slide, prs, assets.get("separator"))
    sw_in = emu_to_inches(prs.slide_width)
    add_title_box(
        slide,
        title,
        left_in=PAGE_MARGIN_IN,
        top_in=3.2,
        width_in=sw_in - 2 * PAGE_MARGIN_IN,
        height_in=1.5,
        font_size_pt=56,
        color=GOLD,
    )

def add_conclusion_slide(prs, assets, links: list):
    slide = prs.slides.add_slide(prs.slide_layouts[6])
    add_full_slide_picture(slide, prs, assets.get("conclusion"))
    sw_in = emu_to_inches(prs.slide_width)
    add_title_box(
        slide,
        "Final Thoughts",
        left_in=PAGE_MARGIN_IN,
        top_in=0.9,
        width_in=sw_in - 2 * PAGE_MARGIN_IN,
        height_in=1.2,
        font_size_pt=52,
        color=GOLD,
    )
    top = 2.4
    for text, url in links:
        add_text_box(
            slide,
            f"{text}: {url}",
            left_in=PAGE_MARGIN_IN,
            top_in=top,
            width_in=sw_in - 2 * PAGE_MARGIN_IN,
            height_in=0.5,
            font_size_pt=22,
            color=WHITE,
        )
        top += 0.6

def add_thankyou_slide(prs, assets):
    slide = prs.slides.add_slide(prs.slide_layouts[6])
    add_full_slide_picture(slide, prs, assets.get("thankyou"))

def add_item_slide(
    prs, item: Item, month_str: str, assets: dict, rail_left_in: float = 3.5, rail_width_in: float = 3.5):
    slide = prs.slides.add_slide(prs.slide_layouts[6])  # blank layout
    sw_in = emu_to_inches(prs.slide_width)
    sh_in = emu_to_inches(prs.slide_height)

    # Draw side rail
    draw_side_rail(slide, prs, rail_left_in, rail_width_in)

    # Add title box
    title = item.title or "No Title"
    title_size = 36 if len(title) <= 48 else 28 if len(title) <= 72 else 24
    add_title_box(
        slide,
        title,
        left_in=rail_left_in + 0.2,
        top_in=0.6,
        width_in=sw_in - rail_left_in - 0.4,
        height_in=1.8,
        font_size_pt=title_size,
        bold=True,
        color=BLACK,
    )

    # Add summary or description
    content = item.summary or item.description or ""
    if content:
        add_text_box(
            slide,
            content,
            left_in=rail_left_in + 0.2,
            top_in=2.1,
            width_in=sw_in - rail_left_in - 0.4,
            height_in=3.3,
            font_size_pt=16,
            bold=False,
            color=RGBColor(32, 32, 32),
        )
    # Add meta info: Feature ID, Status, Product etc.
    meta_left = rail_left_in + 0.35
    meta_top = 0.6
    line_gap = 0.35

    def add_meta(label, value):
        nonlocal meta_top
        if not value:
            return
        add_text_box(
            slide,
            f"{label}: {value}",
            left_in=meta_left,
            top_in=meta_top,
            width_in=rail_width_in - 0.7,
            height_in=0.35,
            font_size_pt=12,
            bold=True,
            color=WHITE,
        )
        meta_top += line_gap

    # Extract metadata
    rid = getattr(item, "roadmap_id", "") or getattr(item, "rid", "")
    rid = rid or ""
    status = getattr(item, "status", "") or ""
    prod_list = ", ".join(item.products) if item.products else ""
    platforms_str = ", ".join(item.platforms) if item.platforms else ""
    audience_str = ", ".join(item.audience) if item.audience else ""
    month_display = month_str or ""

    add_meta("Feature ID", rid)
    add_meta("Status", status)
    add_meta("Products", prod_list)
    add_meta("Platforms", platforms_str)
    add_meta("Audience", audience_str)
    add_meta("Month", month_display)
    if item.url:
        add_text_box(
            slide,
            f"URL: {item.url}",
            left_in=meta_left,
            top_in=meta_top,
            width_in=rail_width_in - 0.7,
            height_in=0.45,
            font_size_pt=11,
            color=RGBColor(200, 230, 255),
        )
        meta_top += line_gap

    # Optional: add branding or background images inside the item slide
    brand_bg = assets.get("brand_bg")
    if brand_bg and os.path.exists(brand_bg):
        try:
            add_picture_safe(slide, brand_bg, left_in=0.2, top_in=sh_in - 1.2, height_in=1.0)
        except Exception:
            pass  # silently ignore issues here

# Note: The above functions (add_cover_slide, add_agenda_slide, etc.) are modular and can be adapted further.



# =========================
# Main build function
# =========================
def build(
    inputs: List[str],
    output_path: str,
    month: Optional[str],
    assets: dict,
    template: Optional[str],
    rail_width: float,
    conclusion_links: Optional[List[tuple[str, str]]] = None,
):
    # Load presentation template if provided
    prs = None
    if template and os.path.exists(template):
        try:
            prs = Presentation(template)
        except Exception as e:
            print(f"Error loading template: {e}")
            prs = Presentation()
    else:
        prs = Presentation()

    # Add cover slide
    try:
        add_cover_slide(prs, assets, assets.get("cover_title"), assets.get("cover_dates"), assets.get("logo"), assets.get("logo2"))
    except Exception as e:
        print(f"Error adding cover slide: {e}")

    # Add agenda slide
    try:
        add_agenda_slide(prs, assets)
    except Exception as e:
        print(f"Error adding agenda slide: {e}")

    # Read and parse input HTML files
    all_items = []
    for path in inputs:
        try:
            if "messagecenter" in path.lower() or "briefing" in path.lower():
                dicts = parse_message_center_html(path, month)
            else:
                dicts = parse_roadmap_html(path, month)
            all_items.extend(_to_item(d) for d in dicts)
        except Exception as e:
            print(f"Error parsing {path}: {e}")

    # Deduplicate items
    seen_keys = set()
    unique_items = []
    for item in all_items:
        key = (item.roadmap_id or item.title or item.url).lower().strip()
        if key and key not in seen_keys:
            seen_keys.add(key)
            unique_items.append(item)

    # Sort items
    unique_items.sort(key=lambda i: (i.products or [], i.title))

    # Group by primary product
    grouped: Dict[str, List[Item]] = {}
    order: List[str] = []
    for item in unique_items:
        prod = item.products[0] if item.products else "General"
        prod = prod.strip() or "General"
        if prod not in grouped:
            grouped[prod] = []
            order.append(prod)
        grouped[prod].append(item)

    # Generate slides per group
    if unique_items:
        for prod in order:
            add_separator_slide(prs, assets, title=f"{prod} updates")
            for item in grouped[prod]:
                try:
                    add_item_slide(
                        prs,
                        item,
                        month_str=month or "",
                        assets=assets,
                        rail_left_in=rail_width,
                        rail_width_in=rail_width,
                    )
                except Exception as e:
                    print(f"Error adding item slide for {item.title}: {e}")
    else:
        # No items: add placeholder slide
        add_separator_slide(prs, assets, title="No updates found")

    # Add conclusion slide
    if not conclusion_links:
        conclusion_links = [
            ("Microsoft Security", "https://www.microsoft.com/en-us/security"),
            ("Azure Updates", "https://azure.microsoft.com/en-us/updates/"),
            ("Dynamics 365 & Power Platform", "https://www.microsoft.com/en-us/dynamics-365/?culture=en-us&country=us"),
            ("Technical Documentation", "https://learn.microsoft.com/en-us/docs/?culture=en-us&country=us"),
        ]
    try:
        add_conclusion_slide(prs, assets, conclusion_links)
    except Exception as e:
        print(f"Error adding conclusion slide: {e}")

    # Add thank you slide
    try:
        add_thankyou_slide(prs, assets)
    except Exception as e:
        print(f"Error adding thank you slide: {e}")

    # Save presentation safely
    saved_path = _safe_save(prs, output_path)
    print(f"Deck saved to: {saved_path}")


# =========================
# CLI Entry Point
# =========================
def main():
    import argparse
    import os

    parser = argparse.ArgumentParser(description="Generate a PowerPoint briefing deck from HTML inputs.")
    parser.add_argument("-i", "--inputs", nargs="+", required=True, help="Paths to input HTML files")
    parser.add_argument("-o", "--output", required=True, help="Output PPTX filename")
    parser.add_argument("--style", default="style_template.yaml", help="Path to style YAML file")
    parser.add_argument("--month", default="", help="Month label, e.g., 'September 2025'")

    # Asset images
    parser.add_argument("--cover", default="", help="Background image for cover slide")
    parser.add_argument("--agenda-bg", dest="agenda", default="", help="Background for agenda slide")
    parser.add_argument("--separator", default="", help="Background for separator slides")
    parser.add_argument("--conclusion-bg", dest="conclusion", default="", help="Background for conclusion slide")
    parser.add_argument("--thankyou", default="", help="Background for thank-you slide")
    parser.add_argument("--brand-bg", default="", help="Background for item slides (brand)")
    parser.add_argument("--cover-title", default="M365 Technical Update Briefing", help="Cover slide title text")
    parser.add_argument("--cover-dates", default="", help="Cover slide date text")
    parser.add_argument("--logo", default="", help="Path to primary logo image")
    parser.add_argument("--logo2", default="", help="Path to secondary logo image")
    
    # Styling options
    parser.add_argument("--rail-width", default=str(DEFAULT_RAIL_WIDTH_IN), help="Rail width in inches (default 3.5)")
    parser.add_argument("--template", default="", help="Path to a PPTX template to use")
    args = parser.parse_args()

    # Load style configuration
    def load_style(path: str):
        import yaml
        with open(path, 'r') as f:
            return yaml.safe_load(f)

    def path_if_exists(p: str) -> str:
        return p if p and os.path.exists(p) else ""

    style_cfg = load_style(args.style)

    # Build assets dictionary
    assets = {
        "cover": path_if_exists(args.cover),
        "agenda": path_if_exists(args.agenda),
        "separator": path_if_exists(args.separator),
        "conclusion": path_if_exists(args.conclusion),
        "thankyou": path_if_exists(args.thankyou),
        "brand_bg": path_if_exists(args.brand_bg),
        "cover_title": args.cover_title,
        "cover_dates": args.cover_dates or args.month,
        "logo": path_if_exists(args.logo),
        "logo2": path_if_exists(args.logo2),
    }

    try:
        rail_w = float(args.rail_width)
    except ValueError:
        rail_w = DEFAULT_RAIL_WIDTH_IN

    # Call your build function with parsed args
    build(
        inputs=args.inputs,
        output_path=args.output,
        month=args.month,
        assets=assets,
        template=args.template,
        rail_width=rail_w,
        conclusion_links=None,  # Or specify custom links here
    )




if __name__ == "__main__":
    main()