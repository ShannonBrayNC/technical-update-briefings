#requires -Version 7.0

#region ---------- Utilities ----------

function ConvertFrom-RoadmapDate {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][string]$Text
    )
    $t = $Text.Trim()

    # Try ISO first
    try {
        return [datetime]::Parse($t, [Globalization.CultureInfo]::InvariantCulture)
    } catch {}

    # "Month CY2025"
    $m = [Text.RegularExpressions.Regex]::Match($t, '^(January|February|March|April|May|June|July|August|September|October|November|December)\s+CY(\d{4})$', 'IgnoreCase')
    if ($m.Success) {
        $month = ([datetime]::ParseExact($m.Groups[1].Value, 'MMMM', [Globalization.CultureInfo]::InvariantCulture)).Month
        $year  = [int]$m.Groups[2].Value
        return [datetime]::new($year, $month, 1, 0, 0, 0, [datetimekind]::Unspecified)
    }

    # "CY2025 Q3"
    $q = [Text.RegularExpressions.Regex]::Match($t, '^CY(\d{4})\s+Q([1-4])$', 'IgnoreCase')
    if ($q.Success) {
        $y  = [int]$q.Groups[1].Value
        $qq = [int]$q.Groups[2].Value
        $m0 = (($qq-1) * 3) + 1
        return [datetime]::new($y, $m0, 1, 0, 0, 0, [datetimekind]::Unspecified)
    }

    return $null
}

function Get-QuarterRange {
    [CmdletBinding()]
    param([Parameter(Mandatory)][datetime]$AnyDateInMonth)
    $y = $AnyDateInMonth.Year
    $m = $AnyDateInMonth.Month
    $qStartMonth = ([math]::Floor(($m-1)/3) * 3) + 1
    $start = [datetime]::new($y, $qStartMonth, 1)
    $end   = $start.AddMonths(3).AddDays(-1)
    [pscustomobject]@{ Start = $start; End = $end }
}

#endregion

#region ---------- Graph plumbing (optional) ----------

function Connect-GraphCertificate {
    <#
      .SYNOPSIS
        Optional cert-based Graph connection for future joins.
    #>
    [CmdletBinding()]
    param(
        [string]$TenantId,
        [string]$ClientId,
        [string]$CertificateThumbprint,
        [string]$CertificatePath,
        [string]$CertificatePassword,
        [ValidateSet('beta','v1.0')][string]$GraphProfile = 'v1.0'
    )

    if (-not (Get-Command Connect-MgGraph -ErrorAction SilentlyContinue)) {
        Write-Warning "Microsoft.Graph not installed; skipping Graph sign-in."
        return
    }
    Select-MgProfile -Name $GraphProfile | Out-Null

    if ($CertificateThumbprint) {
        Connect-MgGraph -TenantId $TenantId -ClientId $ClientId -CertificateThumbprint $CertificateThumbprint | Out-Null
        return
    }
    if ($CertificatePath) {
        $cert = [System.Security.Cryptography.X509Certificates.X509Certificate2]::new(
            $CertificatePath,
            $CertificatePassword,
            [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable
        )
        Connect-MgGraph -TenantId $TenantId -ClientId $ClientId -Certificate $cert | Out-Null
        return
    }
    Write-Warning "No certificate material provided; Connect-GraphCertificate did nothing."
}

#endregion

#region ---------- Fetch / Filter ----------

function Get-Prop {
    param($Object,[string]$Name)
    if ($null -eq $Object) { return $null }
    $p = $Object.PSObject.Properties | Where-Object { $_.Name -ieq $Name } | Select-Object -First 1
    if ($p) { $p.Value } else { $null }
}

function Ensure-StringList {
    param($Value)
    $out = @()
    if ($null -eq $Value) { return @() }

    # If itâ€™s already a list, walk it; otherwise treat as single
    $seq = if ($Value -is [System.Collections.IEnumerable] -and -not ($Value -is [string])) { $Value } else { @($Value) }

    foreach($v in $seq){
        if ($null -eq $v) { continue }
        if ($v -is [string]) {
            $s = $v.Trim()
            if ($s) { $out += $s }
            continue
        }
        # Likely an object like @{name="General Availability"} or @{displayName="GCC"}
        $cand = @('name','displayName','value','title','text','id') |
                ForEach-Object { $prop = $v.PSObject.Properties[$_]; if ($prop) { [string]$prop.Value } }
        $s = ($cand | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)
        if ($s) { $out += $s.Trim() }
    }
    $out
}

function Normalize-Cloud {
    param([string]$Name)
    if ([string]::IsNullOrWhiteSpace($Name)) { return $null }
    $n = $Name.Trim()
    switch -Regex ($n.ToLowerInvariant()) {
        '^(ww|worldwide|standard.*multi.*tenant|commercial)$' { 'Worldwide (Standard Multi-Tenant)'; break }
        '^gcc$'                                              { 'GCC'; break }
        '^(gcch|gcc[- ]?high|us gov(ernment)? high)$'        { 'GCC High'; break }
        '^(dod|us.?do?d)$'                                   { 'DoD'; break }
        default { $n }
    }
}


function Get-RoadmapArrays {
    [CmdletBinding()]
    param([Parameter(Mandatory)][object]$Item)

    $tc = Get-Prop $Item 'tagsContainer'

    # read arrays (handle object or string items)
    $products = @()
    $clouds   = @()
    $phases   = @()
    $plats    = @()

    $p = if ($tc) { Get-Prop $tc 'products' } else { $null }
    if ($p) { $products = Ensure-StringList $p } elseif (Get-Prop $Item 'products') { $products = Ensure-StringList (Get-Prop $Item 'products') }

    $c = if ($tc) { Get-Prop $tc 'cloudInstances' } else { $null }
    if ($c) { $clouds = Ensure-StringList $c } elseif (Get-Prop $Item 'cloudInstances') { $clouds = Ensure-StringList (Get-Prop $Item 'cloudInstances') }

    $r = if ($tc) { (Get-Prop $tc 'releasePhase') } else { $null }
    if ($r) { $phases = Ensure-StringList $r } elseif (Get-Prop $Item 'releasePhase') { $phases = Ensure-StringList (Get-Prop $Item 'releasePhase') }

    $pl = if ($tc) { Get-Prop $tc 'platforms' } else { $null }
    if ($pl) { $plats = Ensure-StringList $pl } elseif (Get-Prop $Item 'platforms') { $plats = Ensure-StringList (Get-Prop $Item 'platforms') }

    # normalize clouds
    $clouds = @($clouds | ForEach-Object { Normalize-Cloud $_ } | Where-Object { $_ })

    # status
    $status = Get-Prop $Item 'status'
    if (-not $status -and $tc) { $status = Get-Prop $tc 'status' }

    # GA month string (for client toggle)
    $gaText = $null
    foreach($nm in @('release','releaseDate','ga','targetRelease')){
        $v = Get-Prop $Item $nm
        if ($v) { $gaText = [string]$v; break }
    }

    [pscustomobject]@{
        Products       = $products
        CloudInstances = $clouds
        ReleasePhases  = $phases
        Platforms      = $plats
        Status         = $status
        GAText         = $gaText
    }
}


function ConvertFrom-RoadmapDate {
    param([string]$Text)
    if ([string]::IsNullOrWhiteSpace($Text)) { return $null }
    $m = [regex]::Match($Text.Trim(), '^(?<mon>[A-Za-z]+)\s+CY(?<yr>\d{4})$')
    if (-not $m.Success) { return $null }
    $monthNames = @{
        january=1; february=2; march=3; april=4; may=5; june=6;
        july=7; august=8; september=9; october=10; november=11; december=12
    }
    $monKey = $m.Groups['mon'].Value.ToLowerInvariant()
    if (-not $monthNames.ContainsKey($monKey)) { return $null }
    $year = [int]$m.Groups['yr'].Value
    $month = $monthNames[$monKey]
    Get-Date -Year $year -Month $month -Day 1 -Hour 0 -Minute 0 -Second 0
}




function Get-RoadmapRaw {
    [CmdletBinding()]
    param([string]$Uri = 'https://www.microsoft.com/releasecommunications/api/v1/m365')
    Invoke-RestMethod -Uri $Uri -Method GET -ErrorAction Stop
}

function Filter-RoadmapItems {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)][object[]]$Items,

        [string[]]$Products,
        [string[]]$CloudInstances,
        [string[]]$ReleasePhase,    # e.g. 'General Availability'
        [string[]]$Platforms,
        [string[]]$Status,          # e.g. 'Launched','In development','Rolling out'

        [Nullable[datetime]]$CreatedSince,
        [Nullable[datetime]]$UpdatedSince,

        [string]$Text
    )

    if ($null -eq $Items) { $Items = @() }

    $prodWant   = @($Products       | Where-Object { $_ -and $_.Trim() })
    $cloudWant  = @($CloudInstances | ForEach-Object { Normalize-Cloud $_ } | Where-Object { $_ })
    $phaseWant  = @($ReleasePhase   | Where-Object { $_ -and $_.Trim() })
    $platWant   = @($Platforms      | Where-Object { $_ -and $_.Trim() })
    $statusWant = @($Status         | Where-Object { $_ -and $_.Trim() })
    $textWant   = ($Text ?? '').Trim()

    # GA synonyms: treat a GA phase request as status=Launched (common for M365 Roadmap)
    $gaPhaseSynonyms   = @('general availability','ga','general-availability')
    $gaStatusSynonymsL = @('launched','available','released')  # lower-case compare

    $out = @()
    foreach($it in $Items){
        $tags = Get-RoadmapArrays -Item $it

        # Created/Updated windows
        if ($CreatedSince) {
            $cd = $null; $c = Get-Prop $it 'created'; if ($c){ try{ $cd = Get-Date $c }catch{} }
            if (-not ($cd -and $cd -ge $CreatedSince)) { continue }
        }
        if ($UpdatedSince) {
            $ud = $null; $u = Get-Prop $it 'modified'; if ($u){ try{ $ud = Get-Date $u }catch{} }
            if (-not ($ud -and $ud -ge $UpdatedSince)) { continue }
        }

        # Products
        if ($prodWant.Count -gt 0) {
            if (-not ($tags.Products | Where-Object { $prodWant -contains $_ } | Select-Object -First 1)) { continue }
        }

        # Clouds
        if ($cloudWant.Count -gt 0) {
            if (-not ($tags.CloudInstances | Where-Object { $cloudWant -contains $_ } | Select-Object -First 1)) { continue }
        }

        # ReleasePhase + Status
        if ($phaseWant.Count -gt 0 -or $statusWant.Count -gt 0) {
            $phaseTxts  = @($tags.ReleasePhases | ForEach-Object { $_.ToString() })
            $statusText = ($tags.Status ?? '').ToString()

            $phaseOk = $true
            if ($phaseWant.Count -gt 0) {
                $phaseOk = $false
                $hasRealPhase = ($phaseTxts | Where-Object { $_ -and $_.Trim() } | Select-Object -First 1)

                foreach($w in $phaseWant){
                    $wL = $w.ToLower().Trim()

                    $direct = $false
                    if ($hasRealPhase) {
                        $direct = $phaseTxts | Where-Object { $_ -and $_.ToLower().Contains($wL) } | Select-Object -First 1
                    }

                    $viaStatus = $false
                    if ($gaPhaseSynonyms -contains $wL) {
                        if ($statusText) {
                            $stL = $statusText.ToLower()
                            if ($gaStatusSynonymsL | Where-Object { $stL.Contains($_) } | Select-Object -First 1) { $viaStatus = $true }
                        }
                    }

                    if ($direct -or $viaStatus) { $phaseOk = $true; break }
                }
            }

            $statusOk = $true
            if ($statusWant.Count -gt 0) {
                $statusOk = ($statusWant | Where-Object { $statusText -and $statusText.ToLower() -eq $_.ToLower() } | Select-Object -First 1)
            }

            if (-not ($phaseOk -and $statusOk)) { continue }
        }

        # Platforms
        if ($platWant.Count -gt 0) {
            if (-not ($tags.Platforms | Where-Object { $platWant -contains $_ } | Select-Object -First 1)) { continue }
        }

        # Free text
        if ($textWant) {
            $title = [string](Get-Prop $it 'title')
            $desc  = [string](Get-Prop $it 'description')
            $hay   = @(
                $title, $desc,
                ($tags.Products -join ' '),
                ($tags.CloudInstances -join ' '),
                ($tags.ReleasePhases -join ' '),
                ($tags.Platforms -join ' '),
                $tags.Status
            ) -join ' '
            if (-not ($hay -and $hay.ToLower().Contains($textWant.ToLower()))) { continue }
        }

        $out += $it
    }

    ,$out
}


#endregion

#region ---------- HTML builder (with inline ES5 client) ----------

function New-RoadmapHtml {
    [CmdletBinding()]
    param(
        [AllowEmptyCollection()][object[]]$Items,
        [string]$Title,
        [string]$Subtitle,
        [ValidateSet('Cloud','Product','None')][string]$GroupBy = 'Cloud',
        [Nullable[datetime]]$GAFrom,
        [Nullable[datetime]]$GATo
    )

    if ($null -eq $Items) { $Items = @() }

    # Derive flat lists (pull via Get-RoadmapArrays so we see tagsContainer.*)
    $tagsList = @()
    foreach($it in $Items){ $tagsList += ,(Get-RoadmapArrays -Item $it) }

    $allProducts = @($tagsList.Products       | ForEach-Object { $_ } | Where-Object { $_ } | Sort-Object -Unique)
    $allClouds   = @($tagsList.CloudInstances | ForEach-Object { $_ } | Where-Object { $_ } | Sort-Object -Unique)
    $allPhase    = @($tagsList.ReleasePhases  | ForEach-Object { $_ } | Where-Object { $_ } | Sort-Object -Unique)
    $allStatus   = @($tagsList.Status         | Where-Object { $_ }   | Sort-Object -Unique)

    $gaFromIso = if ($GAFrom) { (Get-Date $GAFrom -Format 'yyyy-MM-dd') } else { '' }
    $gaToIso   = if ($GATo)   { (Get-Date $GATo   -Format 'yyyy-MM-dd') } else { '' }

    if ($Items.Count -eq 0) {
@"
<!doctype html><html><head><meta charset="utf-8"><title>$Title</title>
<style>body{font-family:Segoe UI,Arial,sans-serif;margin:24px;color:#1f2937}.card{border:1px solid #e5e7eb;border-radius:12px;padding:20px;max-width:960px}.muted{color:#6b7280}</style>
</head><body data-gafrom="$gaFromIso" data-gato="$gaToIso">
<h1 style="margin:0 0 4px 0;">$Title</h1><div class="muted">$Subtitle</div>
<div class="card" style="margin-top:16px"><div><strong>No roadmap items match the current filters.</strong></div>
<div class="muted" style="margin-top:6px">Try clearing one or more filters (Cloud, Release Phase, Technology) or broaden the GA window.</div></div>
</body></html>
"@
        return
    }

    # Grouping
    $groups = @{}
    if ($GroupBy -eq 'Cloud') {
        foreach($it in $Items){
            $t = Get-RoadmapArrays -Item $it
            $clouds = if ($t.CloudInstances.Count) { $t.CloudInstances } else { @('Unspecified') }
            foreach($cl in $clouds){
                if (-not $groups.ContainsKey($cl)) { $groups[$cl] = New-Object System.Collections.Generic.List[object] }
                $groups[$cl].Add($it)
            }
        }
    } elseif ($GroupBy -eq 'Product') {
        foreach($it in $Items){
            $t = Get-RoadmapArrays -Item $it
            $prods = if ($t.Products.Count) { $t.Products } else { @('Unspecified') }
            foreach($p in $prods){
                if (-not $groups.ContainsKey($p)) { $groups[$p] = New-Object System.Collections.Generic.List[object] }
                $groups[$p].Add($it)
            }
        }
    } else {
        $groups['All Items'] = New-Object System.Collections.Generic.List[object]
        foreach($it in $Items){ $groups['All Items'].Add($it) }
    }

    $order = if ($GroupBy -eq 'Cloud') {
        $known = @('Worldwide (Standard Multi-Tenant)','GCC','GCC High','DoD','Unspecified')
        $rest  = @($groups.Keys | Where-Object { $known -notcontains $_ } | Sort-Object)
        @($known + $rest | Where-Object { $groups.ContainsKey($_) })
    } else {
        @($groups.Keys | Sort-Object)
    }

    $cloudOptions   = ($allClouds   | ForEach-Object { "<label><input type='checkbox' class='f-cloud'  value='$_' checked> $_</label>" }) -join ' '
    $productOptions = ($allProducts | ForEach-Object { "<label><input type='checkbox' class='f-prod'   value='$_' checked> $_</label>" }) -join ' '
    $phaseOptions   = ($allPhase    | ForEach-Object { "<label><input type='checkbox' class='f-phase'  value='$_' checked> $_</label>" }) -join ' '
    $statusOptions  = ($allStatus   | ForEach-Object { "<label><input type='checkbox' class='f-status' value='$_' checked> $_</label>" }) -join ' '

@"
<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>$Title</title>
<style>
  body{font-family:Segoe UI,Arial,sans-serif;margin:24px;color:#111827;background:#fff}
  h1{margin:0}
  .muted{color:#6b7280}
  .panel{border:1px solid #e5e7eb;border-radius:12px;padding:14px;margin:14px 0}
  .group{margin-top:24px}
  .ghead{font-weight:600;margin-bottom:10px}
  .card{border:1px solid #e5e7eb;border-radius:12px;padding:14px;margin:10px 0}
  .meta{font-size:12px;color:#6b7280;margin-top:6px}
  .row{display:flex;gap:24px;flex-wrap:wrap}
  .row label{display:inline-flex;align-items:center;gap:6px;margin:4px 10px 4px 0}
  .btn{display:inline-block;padding:6px 12px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer}
  .controls{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .search{border:1px solid #d1d5db;border-radius:8px;padding:6px 10px;min-width:220px}
  .seg{display:inline-flex;border:1px solid #d1d5db;border-radius:8px;overflow:hidden}
  .seg label{padding:6px 10px;cursor:pointer;border-right:1px solid #e5e7eb}
  .seg label:last-child{border-right:none}
  .seg input{display:none}
  .seg .on{background:#111827;color:#fff}
  .hidden{display:none !important}
</style>
</head>
<body data-gafrom="$gaFromIso" data-gato="$gaToIso">
  <h1>$Title</h1>
  <div class="muted">$Subtitle</div>

  <div class="panel">
    <div class="controls">
      <input id="q" class="search" placeholder="Search title/description..." />
      <div class="seg" id="gaSeg">
        <label id="gaExactLbl"><input type="radio" name="gaMode" id="gaExact" checked> Exact Month Only</label>
        <label id="gaQuarterLbl"><input type="radio" name="gaMode" id="gaQuarter"> Include Entire Quarter</label>
      </div>
      <button id="apply" class="btn">Apply</button>
      <button id="clear" class="btn">Clear All</button>
      <span class="muted" id="count"></span>
    </div>
    <div class="row" style="margin-top:8px"><strong>Cloud:</strong> $cloudOptions</div>
    <div class="row"><strong>Technology:</strong> $productOptions</div>
    <div class="row"><strong>Phase:</strong> $phaseOptions</div>
    <div class="row"><strong>Status:</strong> $statusOptions</div>
  </div>

  <div id="groups">
"@ | Out-String

    foreach($g in $order){
        $list = @($groups[$g]); if ($list.Count -eq 0) { continue }
        "<div class='group' data-group='$g'><div class='ghead'>$g</div>" | Out-String
        foreach($it in $list){
            $t = Get-RoadmapArrays -Item $it
            $title = [string](Get-Prop $it 'title')
            $desc  = [string](Get-Prop $it 'description')
            $status = $t.Status
            $phase  = ($t.ReleasePhases -join ', ')
            $prod   = ($t.Products -join ', ')
            $clds   = ($t.CloudInstances -join ', ')
            $mods   = $null; $modVal = Get-Prop $it 'modified'; if ($modVal) { try { $mods = (Get-Date $modVal).ToString('yyyy-MM-dd') } catch {} }
            $gaText = $t.GAText

@"
  <div class='card'
       data-clouds='$clds'
       data-prods='$prod'
       data-phase='$phase'
       data-status='$status'
       data-ga='$gaText'
       data-text='$(($title + " " + $desc).Replace("'","`""))'>
    <div><strong>$title</strong></div>
    <div class='meta'>$phase Â· $status Â· $clds Â· $prod$(if($mods){" Â· Updated $mods"})$(if($gaText){" Â· GA $gaText"})</div>
    $(if($desc){ "<div style='margin-top:8px'>$desc</div>" })
  </div>
"@
        }
        "</div>" | Out-String
    }

@"
  </div>

<script>
(function(){
  const MONTHS={january:1,february:2,march:3,april:4,may:5,june:6,july:7,august:8,september:9,october:10,november:11,december:12};
  function parseGaText(txt){ if(!txt) return null; const m=txt.trim().toLowerCase().match(/^([a-z]+)\\s+cy(\\d{4})$/i); if(!m) return null;
    const mon=MONTHS[m[1].toLowerCase()]; if(!mon) return null; return {y:parseInt(m[2],10),m:mon}; }
  function isoToYm(iso){ if(!iso) return null; const m=iso.match(/^(\\d{4})-(\\d{2})-/); if(!m) return null; return {y:parseInt(m[1],10),m:parseInt(m[2],10)}; }
  function qOf(m){ return Math.floor((m-1)/3)+1; }
  function sameMonth(a,b){ return a && b && a.y===b.y && a.m===b.m; }
  function sameQuarter(a,b){ return a && b && a.y===b.y && qOf(a.m)===qOf(b.m); }
  function getChecked(cls){ return Array.from(document.querySelectorAll('input.'+cls+':checked')).map(x=>x.value); }
  function allSelected(cls){ const xs=Array.from(document.querySelectorAll('input.'+cls)); return xs.length>0 && xs.every(x=>x.checked); }
  function matchAny(hay, wants){ if (wants.length===0) return true; if(!hay) return false; const h=hay.toLowerCase(); return wants.some(w=>h.includes(w.toLowerCase())); }

  const base = { from: isoToYm(document.body.dataset.gafrom||''), to: isoToYm(document.body.dataset.gato||'') };

  function apply(){
    const q=(document.getElementById('q').value||'').trim().toLowerCase();
    const clouds = getChecked('f-cloud');
    const prods  = getChecked('f-prod');
    const phases = getChecked('f-phase');
    const stats  = getChecked('f-status');
    const gaQuarter = document.getElementById('gaQuarter').checked;

    const cloudsEff = allSelected('f-cloud') ? [] : clouds;

    let shown=0;
    document.querySelectorAll('.group').forEach(g=>{
      let gShown=0;
      g.querySelectorAll('.card').forEach(card=>{
        const txt = (card.dataset.text||'').toLowerCase();
        const cl  = card.dataset.clouds||'';
        const pr  = card.dataset.prods||'';
        const ph  = card.dataset.phase||'';
        const st  = card.dataset.status||'';
        const ga  = parseGaText(card.dataset.ga||'');

        let hitGA=true;
        const baseMonth = base.from; // PowerShell set this to the month we care about
        if (baseMonth){
          hitGA = gaQuarter ? sameQuarter(ga, baseMonth) : sameMonth(ga, baseMonth);
        }

        const ok = hitGA
          && (!q || txt.includes(q))
          && matchAny(cl, cloudsEff)
          && matchAny(pr, prods)
          && matchAny(ph, phases)
          && matchAny(st, stats);

        card.classList.toggle('hidden', !ok);
        if (ok){ shown++; gShown++; }
      });
      g.classList.toggle('hidden', gShown===0);
    });

    document.getElementById('count').textContent = shown + ' item' + (shown===1?'':'s');
    document.getElementById('gaExactLbl').classList.toggle('on', !gaQuarter);
    document.getElementById('gaQuarterLbl').classList.toggle('on', gaQuarter);
  }

  document.getElementById('apply').addEventListener('click', apply);
  document.getElementById('clear').addEventListener('click', ()=>{
    document.getElementById('q').value='';
    document.querySelectorAll('.panel input[type=checkbox]').forEach(c=>c.checked=false);
    document.getElementById('gaExact').checked=true;
    apply();
  });
  document.getElementById('gaExact').addEventListener('change', apply);
  document.getElementById('gaQuarter').addEventListener('change', apply);
  apply();
})();
</script>

</body></html>
"@
}



#endregion

#region ---------- Public cmdlets ----------

function Get-M365Roadmap {
    [CmdletBinding()]
    param(
        [switch]$NextMonth,
        [switch]$ThisMonth,

        [ValidateSet('Cloud','Product','Technology','None')]
        [string]$GroupBy = 'Cloud',

        [int]$Top = 0,

        [string[]]$Products,
        [string[]]$CloudInstances,
        [string[]]$Platforms,
        [string[]]$Status,
        [string[]]$ReleasePhase,   # e.g. 'General Availability' (will map to status Launched)

        [Nullable[datetime]]$CreatedSince,
        [Nullable[datetime]]$UpdatedSince,

        [string]$Text,

        [string]$Title = 'Roadmap Briefing',
        [string]$OutputPath
    )

    Write-Verbose "Begin Get-M365Roadmap"

    # GA month window is now DISPLAY-ONLY. We do NOT filter server-side by month.
    $subtitle = Get-Date -Format 'yyyy-MM-dd'
    if ($ThisMonth) {
        $first = Get-Date -Day 1
        $last  = $first.AddMonths(1).AddDays(-1)
        $subtitle = "This month ($($first.ToShortDateString()) - $($last.ToShortDateString()))"
    }
    elseif ($NextMonth) {
        $first = (Get-Date -Day 1).AddMonths(1)
        $last  = $first.AddMonths(1).AddDays(-1)
        $subtitle = "Next month ($($first.ToShortDateString()) - $($last.ToShortDateString()))"
    }

    # Fetch
    $uri = 'https://www.microsoft.com/releasecommunications/api/v1/m365'
    Write-Verbose "Output path: $OutputPath"
    Write-Verbose "Fetching Roadmap: $uri"

    $raw = Invoke-RestMethod -Uri $uri
    $items = if ($raw.PSObject.Properties['features']) { @($raw.features) } else { @($raw) }
    Write-Verbose "Items fetched: $($items.Count)"

    # Filter (NO GA window filter here)
    $items = Filter-RoadmapItems -Items $items `
        -Products $Products -CloudInstances $CloudInstances `
        -Platforms $Platforms -Status $Status -ReleasePhase $ReleasePhase `
        -CreatedSince $CreatedSince -UpdatedSince $UpdatedSince -Text $Text

    Write-Verbose "Items after filter: $($items.Count)"

    # Sort by modified desc if present, else created
    if ($items.Count -gt 1) {
        $sortable = @()
        foreach($it in $items){
            $val = $null
            $m = $it.modified; $c = $it.created
            if ($m) { try{ $val = Get-Date $m }catch{} }
            if (-not $val -and $c) { try{ $val = Get-Date $c }catch{} }
            if (-not $val) { $val = Get-Date 0 }
            $sortable += [pscustomobject]@{ _key = $val; _it = $it }
        }
        $items = @($sortable | Sort-Object -Property _key -Descending | ForEach-Object { $_._it })
    }

    if ($Top -gt 0 -and $items.Count -gt $Top) {
        $items = @($items | Select-Object -First $Top)
    }

    # Build HTML (client handles GA month/quarter toggles, checkboxes, etc.)
    $html = New-RoadmapHtml -Items $items -Title $Title -Subtitle $subtitle -GroupBy $GroupBy

    # Write file
    if (-not $OutputPath) {
        $name = "Roadmap_Briefing_{0}.html" -f (Get-Date -Format 'yyyyMMdd-HHmmss')
        $OutputPath = Join-Path -Path (Get-Location) -ChildPath $name
    }
    Set-Content -Path $OutputPath -Value $html -Encoding UTF8
    Write-Host "Roadmap briefing written to: $OutputPath"
    return $OutputPath
}


function Get-M365ServiceMessages {
    [CmdletBinding()] param()
    Write-Warning "Get-M365ServiceMessages is not implemented in this module."
}

Export-ModuleMember -Function Connect-GraphCertificate, Get-M365Roadmap, Get-M365ServiceMessages

#endregion

