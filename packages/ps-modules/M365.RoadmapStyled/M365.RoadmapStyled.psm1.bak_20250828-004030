#requires -Version 5.1

#region ===== Utilities =====

function ConvertTo-StringList {
  param([object]$Value)
  if ($null -eq $Value) { return @() }
  if ($Value -is [string]) { return @($Value) }
  if ($Value -is [System.Collections.IEnumerable]) {
    return @($Value | Where-Object { $_ -ne $null } | ForEach-Object { [string]$_ })
  }
  return @([string]$Value)
}

function Get-RoadmapTags {
  <#
    .SYNOPSIS
      Normalizes Products/Platforms/Clouds/Phases for a roadmap item.
  #>
  param([Parameter(Mandatory)][object]$Item)

  $tc = if ($Item.PSObject.Properties['tagsContainer']) { $Item.tagsContainer } else { $null }

  $products  = if ($tc -and $tc.PSObject.Properties['products'])  { $tc.products }  else { $Item.products }
  $platforms = if ($tc -and $tc.PSObject.Properties['platforms']) { $tc.platforms } else { $Item.platforms }
  $clouds    = if ($tc -and $tc.PSObject.Properties['clouds'])    { $tc.clouds }    else { $Item.clouds }
  $phases    = if ($tc -and $tc.PSObject.Properties['phases'])    { $tc.phases }    else { $Item.phases }

  [pscustomobject]@{
    Products  = ConvertTo-StringList $products
    Platforms = ConvertTo-StringList $platforms
    Clouds    = ConvertTo-StringList $clouds
    Phases    = ConvertTo-StringList $phases
  }
}

function ConvertTo-CloudName {
  param([string]$Name)
  if ([string]::IsNullOrWhiteSpace($Name)) { return $Name }
  $n = $Name.Trim()
  switch -Regex ($n) {
    '^Worldwide'                 { 'Worldwide (Standard Multi-Tenant)'; break }
    'GCC High'                   { 'GCC High'; break }
    'GCC'                        { 'GCC'; break }
    'DoD|DOD|Department of Defense' { 'DoD'; break }
    default { $n }
  }
}

function ConvertTo-PhaseName {
  param([string]$Name)
  if ([string]::IsNullOrWhiteSpace($Name)) { return $Name }
  $n = $Name.Trim()
  switch -Regex ($n) {
    'General\s+Availability' { 'General Availability'; break }
    'Preview'                { 'Preview'; break }
    'Rolling\s+out'          { 'Rolling out'; break }
    'In\s+development'       { 'In development'; break }
    'Launched'               { 'Launched'; break }
    'Cancelled|Canceled'     { 'Cancelled'; break }
    default { $n }
  }
}

function Try-ParseDate {
  [OutputType([bool])]
  param(
    [string]$Text,
    [ref]$DateOut
  )
  $DateOut.Value = [datetime]::MinValue
  if ([string]::IsNullOrWhiteSpace($Text)) { return $false }

  $d = [datetime]::MinValue
  if ([datetime]::TryParse($Text, [ref]$d)) { $DateOut.Value = $d; return $true }

  # Month + Year (optionally with CY)
  if ($Text -match '(January|February|March|April|May|June|July|August|September|October|November|December)\s+(?:CY)?(\d{4})') {
    $m = $matches[1]; $y = [int]$matches[2]
    $DateOut.Value = [datetime]::ParseExact("01 $m $y", 'dd MMMM yyyy', [System.Globalization.CultureInfo]::InvariantCulture)
    return $true
  }

  # CYyyyy -> Jan 1 that year
  if ($Text -match 'CY(\d{4})') {
    $y = [int]$matches[1]
    $DateOut.Value = [datetime]::ParseExact("01 January $y", 'dd MMMM yyyy', [System.Globalization.CultureInfo]::InvariantCulture)
    return $true
  }

  return $false
}

function Select-RoadmapItems {
  [CmdletBinding()]
  param(
    [Parameter(Mandatory)][object[]]$Items,

    [string[]]$Products,
    [string[]]$Platforms,
    [string[]]$CloudInstances,
    [string[]]$ReleasePhase,
    [string[]]$Status,
    [string]  $Text,
    [Nullable[datetime]]$UpdatedSince,
    [Nullable[datetime]]$CreatedSince,
    [Nullable[datetime]]$GAFrom,
    [Nullable[datetime]]$GATo
  )

  $wantProducts  = @($Products      | ForEach-Object { $_.ToString().ToLowerInvariant().Trim() })
  $wantPlatforms = @($Platforms     | ForEach-Object { $_.ToString().ToLowerInvariant().Trim() })
  $wantClouds    = @($CloudInstances| ForEach-Object { (ConvertTo-CloudName $_).ToLowerInvariant() })
  $wantPhases    = @($ReleasePhase  | ForEach-Object { (ConvertTo-PhaseName $_).ToLowerInvariant() })
  $wantStatus    = @($Status        | ForEach-Object { $_.ToString().ToLowerInvariant().Trim() })
  $needle        = if ([string]::IsNullOrWhiteSpace($Text)) { $null } else { $Text.ToLowerInvariant() }

  $out = New-Object System.Collections.Generic.List[object]

  foreach ($it in $Items) {
    $tags = Get-RoadmapTags -Item $it
    $p  = @($tags.Products  | ForEach-Object { $_.ToLowerInvariant() })
    $pl = @($tags.Platforms | ForEach-Object { $_.ToLowerInvariant() })
    $c  = @($tags.Clouds    | ForEach-Object { (ConvertTo-CloudName $_).ToLowerInvariant() })
    $ph = @($tags.Phases    | ForEach-Object { (ConvertTo-PhaseName $_).ToLowerInvariant() })

    if ($needle) {
      $hay = (("{0} {1}" -f [string]$it.title, [string]$it.description)).ToLowerInvariant()
      if ($hay.IndexOf($needle) -lt 0) { continue }
    }

    if ($wantProducts.Count  -gt 0 -and (-not ($p  | Where-Object { $wantProducts  -contains $_ }))) { continue }
    if ($wantPlatforms.Count -gt 0 -and (-not ($pl | Where-Object { $wantPlatforms -contains $_ }))) { continue }
    if ($wantClouds.Count    -gt 0 -and (-not ($c  | Where-Object { $wantClouds    -contains $_ }))) { continue }
    if ($wantPhases.Count    -gt 0 -and (-not ($ph | Where-Object { $wantPhases    -contains $_ }))) { continue }

    if ($wantStatus.Count -gt 0) {
      $st = ([string]$it.status).ToLowerInvariant()
      if (-not ($wantStatus -contains $st)) { continue }
    }

    if ($UpdatedSince.HasValue) {
      $mod = $null; [void][datetime]::TryParse([string]$it.modified, [ref]$mod)
      if ($mod -and $mod -lt $UpdatedSince.Value) { continue }
    }
    if ($CreatedSince.HasValue) {
      $cr = $null; [void][datetime]::TryParse([string]$it.created, [ref]$cr)
      if ($cr -and $cr -lt $CreatedSince.Value) { continue }
    }

    if ($GAFrom.HasValue -or $GATo.HasValue) {
      $gaText = [string]$it.ga
      $d1 = $null
      $hit = $false
      if ($gaText -and (Try-ParseDate -Text $gaText -DateOut ([ref]$d1))) { $hit = $true }
      if ($hit) {
        if ($GAFrom.HasValue -and $d1 -lt $GAFrom.Value) { continue }
        if ($GATo.HasValue   -and $d1 -gt $GATo.Value)   { continue }
      }
      # If we cannot infer a GA month, keep it.
    }

    $out.Add($it) | Out-Null
  }

  ,$out.ToArray()
}

function ConvertTo-HtmlSafe {
  param([string]$s)
  if ($null -eq $s) { return '' }
  return ($s -replace '&','&amp;'
             -replace '<','&lt;'
             -replace '>','&gt;'
             -replace '"','&quot;'
             -replace "'","&#39;")}

#endregion

#region ===== HTML builder =====

function New-RoadmapHtml {
  [CmdletBinding()]
  param(
    [Parameter(Mandatory)][object[]]$Items,
    [string]$Title = 'Roadmap Briefing',
    [string]$Subtitle = '',
    [ValidateSet('Cloud','Product','None')] [string]$GroupBy = 'Cloud'
  )

  # collect facets
  $allClouds    = [System.Collections.Generic.HashSet[string]]::new([StringComparer]::OrdinalIgnoreCase)
  $allProducts  = [System.Collections.Generic.HashSet[string]]::new([StringComparer]::OrdinalIgnoreCase)
  $allPlatforms = [System.Collections.Generic.HashSet[string]]::new([StringComparer]::OrdinalIgnoreCase)
  $allStatuses  = [System.Collections.Generic.HashSet[string]]::new([StringComparer]::OrdinalIgnoreCase)

  foreach ($it in $Items) {
    $tags = Get-RoadmapTags -Item $it
    foreach($v in $tags.Clouds)    { $null = $allClouds.Add( (ConvertTo-CloudName $v) ) }
    foreach($v in $tags.Products)  { $null = $allProducts.Add($v) }
    foreach($v in $tags.Platforms) { $null = $allPlatforms.Add($v) }
    if ($it.status) { $null = $allStatuses.Add([string]$it.status) }
  }

  $clouds    = @($allClouds    | Sort-Object)
  $products  = @($allProducts  | Sort-Object)
  $platforms = @($allPlatforms | Sort-Object)
  $statuses  = @($allStatuses  | Sort-Object)

  # Emoji maps (edit to taste)
  $productEmoji = @{
    'Microsoft Teams' = 'üí¨'
    'SharePoint'      = 'üóÇÔ∏è'
    'OneDrive'        = '‚òÅÔ∏è'
    'Exchange'        = '‚úâÔ∏è'
    'Microsoft Intune'= 'üîê'
    'Defender'        = 'üõ°Ô∏è'
    'Viva'            = 'üåü'
  }
  $statusEmoji = @{
    'Launched'        = '‚úÖ'
    'Rolling out'     = 'üöö'
    'In development'  = 'üß™'
    'Preview'         = 'üß™'
    'Cancelled'       = '‚õî'
  }

  $sb = New-Object System.Text.StringBuilder

  $null = $sb.AppendLine('<!DOCTYPE html>')
  $null = $sb.AppendLine('<meta charset="utf-8" />')
  $null = $sb.AppendLine("<title>$(ConvertTo-HtmlSafe $Title)</title>")

  $css = @'
<style>
  :root { font-family: Segoe UI, system-ui, -apple-system, Roboto, Arial, sans-serif; }
  body { margin: 24px; }
  h1 { margin: 0 0 4px 0; font-size: 24px; }
  .sub { color:#666; margin-bottom:16px; }
  .controls { display:flex; flex-wrap:wrap; gap:12px; align-items:flex-end; margin: 16px 0 12px 0; }
  fieldset { border:1px solid #ddd; border-radius:10px; padding:10px 12px; }
  legend { color:#555; font-size:12px; }
  .chips { display:flex; flex-wrap:wrap; gap:6px; max-height:112px; overflow:auto; }
  .chip { display:inline-flex; gap:6px; align-items:center; border:1px solid #ccc; padding:4px 8px; border-radius:999px; font-size:12px; }
  .btn { padding:8px 12px; border-radius:10px; border:1px solid #bbb; background:#fafafa; cursor:pointer; }
  .btn.primary { background:#2563eb; color:white; border-color:#2563eb; }
  .group { margin-top:16px; }
  .group h2 { font-size:18px; margin:14px 0 6px 0; }
  .cards { display:grid; grid-template-columns: repeat(auto-fill,minmax(320px,1fr)); gap:10px; }
  .card { border:1px solid #e5e7eb; border-radius:14px; padding:12px; background:white; box-shadow:0 1px 2px rgba(0,0,0,.05); }
  .meta { display:flex; gap:6px; flex-wrap:wrap; margin:8px 0 2px 0; }
  .badge { font-size:11px; border:1px solid #ddd; padding:2px 6px; border-radius:999px; background:#f9fafb; }
  .muted { color:#6b7280; font-size:12px; }
  .hidden { display:none !important; }
</style>
'@
  $null = $sb.AppendLine($css)

  $null = $sb.AppendLine('<div id="app">')
  $null = $sb.AppendLine("<h1>$(ConvertTo-HtmlSafe $Title)</h1>")
  if ($Subtitle) { $null = $sb.AppendLine("<div class='sub'>$(ConvertTo-HtmlSafe $Subtitle)</div>") }

  # Controls
  $null = $sb.AppendLine('<div class="controls">')

  # Clouds
  $null = $sb.AppendLine('<fieldset><legend>Cloud instances</legend><div class="chips" id="clouds">')
  foreach($c in $clouds){
    $id = [Guid]::NewGuid().ToString('N')
    $cc = ConvertTo-HtmlSafe $c
    $null = $sb.AppendLine("<label class='chip'><input type='checkbox' data-facet='cloud' value='$cc' checked /> $cc</label>")
  }
  $null = $sb.AppendLine('</div></fieldset>')

  # Products
  $null = $sb.AppendLine('<fieldset><legend>Technology</legend><div class="chips" id="products">')
  foreach($p in $products){
    $id = [Guid]::NewGuid().ToString('N')
    $pp = ConvertTo-HtmlSafe $p
    $emoji = $productEmoji[$p]
    $txt = if ($emoji) { "$emoji&nbsp;$pp" } else { $pp }
    $null = $sb.AppendLine("<label class='chip'><input type='checkbox' data-facet='product' value='$pp' /> $txt</label>")
  }
  $null = $sb.AppendLine('</div></fieldset>')

  # Status
  $null = $sb.AppendLine('<fieldset><legend>Status</legend><div class="chips" id="statuses">')
  foreach($s in $statuses){
    $ss = ConvertTo-HtmlSafe $s
    $emoji = $statusEmoji[$s]
    $txt = if ($emoji) { "$emoji&nbsp;$ss" } else { $ss }
    $null = $sb.AppendLine("<label class='chip'><input type='checkbox' data-facet='status' value='$ss' /> $txt</label>")
  }
  $null = $sb.AppendLine('</div></fieldset>')

  # Buttons + GA toggle
  $null = $sb.AppendLine('<div>')
  $null = $sb.AppendLine('<button class="btn primary" id="apply">Apply</button> ')
  $null = $sb.AppendLine('<button class="btn" id="clear">Clear</button> ')
  $null = $sb.AppendLine('<label class="chip"><input type="checkbox" id="gaQuarter" /> Include entire quarter</label>')
  $null = $sb.AppendLine('</div>')

  $null = $sb.AppendLine('</div>') # controls

  # Group + cards
  function _groupKey($it, $groupBy){
    switch($groupBy){
      'Cloud'   { (Get-RoadmapTags -Item $it).Clouds | Select-Object -First 1 | ForEach-Object { ConvertTo-CloudName $_ } }
      'Product' { (Get-RoadmapTags -Item $it).Products | Select-Object -First 1 }
      default   { 'All items' }
    }
  }

  $groups = @{}
  foreach($it in $Items){
    $gk = (_groupKey $it $GroupBy)
    if (-not $groups.ContainsKey($gk)) { $groups[$gk] = New-Object System.Collections.Generic.List[object] }
    $groups[$gk].Add($it)
  }

  foreach($gk in ($groups.Keys | Sort-Object)){
    $cards = $groups[$gk]
    $gh = ConvertTo-HtmlSafe ([string]$gk)
    $null = $sb.AppendLine("<div class='group' data-group='$gh'><h2>$gh</h2><div class='cards'>")

    foreach($it in $cards){
      $tags = Get-RoadmapTags -Item $it
      $c  = @($tags.Clouds    | ForEach-Object { ConvertTo-CloudName $_ })
      $p  = @($tags.Products)
      $pl = @($tags.Platforms)
      $ph = @($tags.Phases | ForEach-Object { ConvertTo-PhaseName $_ })
      $st = [string]$it.status

      $title = ConvertTo-HtmlSafe ([string]$it.title)
      $desc  = ConvertTo-HtmlSafe ([string]$it.description)
      $ga    = ConvertTo-HtmlSafe ([string]$it.ga)

      $dc = ($c -join ', ')
      $dp = ($p -join ', ')
      $dph= ($ph -join ', ')
      $dst= ($st)

      $null = $sb.AppendLine(("<div class='card' data-clouds='{0}' data-products='{1}' data-status='{2}' data-phases='{3}'>" -f
        (ConvertTo-HtmlSafe ($dc.ToLowerInvariant())),
        (ConvertTo-HtmlSafe ($dp.ToLowerInvariant())),
        (ConvertTo-HtmlSafe ($dst.ToLowerInvariant())),
        (ConvertTo-HtmlSafe ($dph.ToLowerInvariant()))
      ))
      $null = $sb.AppendLine("<div class='title'><strong>$title</strong></div>")
      $null = $sb.AppendLine("<div class='meta'>")
      foreach($cc in $c){ $null = $sb.AppendLine("<span class='badge'>$([ConvertTo-HtmlSafe]$cc)</span>") }
      foreach($pp in $p){
        $em = $productEmoji[$pp]
        $lab = if ($em) { "$em&nbsp;$pp" } else { $pp }
        $null = $sb.AppendLine("<span class='badge'>$([ConvertTo-HtmlSafe]$lab)</span>")
      }
      if ($st) {
        $em = $statusEmoji[$st]
        $lab = if ($em) { "$em&nbsp;$st" } else { $st }
        $null = $sb.AppendLine("<span class='badge'>$([ConvertTo-HtmlSafe]$lab)</span>")
      }
      if ($ga) { $null = $sb.AppendLine("<span class='badge'>GA: $ga</span>") }
      $null = $sb.AppendLine("</div>")
      if ($desc) { $null = $sb.AppendLine("<div class='muted'>$desc</div>") }
      $null = $sb.AppendLine("</div>") # card
    }

    $null = $sb.AppendLine("</div></div>") # cards/group
  }

  $null = $sb.AppendLine('</div>') # app

  $js = @'
<script>
(function(){
  function normSet(list){ return new Set((list||[]).map(s => s.toLowerCase())); }
  function getCheckedVals(facet){
    return Array.from(document.querySelectorAll("input[type=checkbox][data-facet='"+facet+"']:checked"))
      .map(x => x.value.trim().toLowerCase());
  }
  function splitCSV(s){
    return (s||'').split(',').map(t => t.trim()).filter(Boolean);
  }
  function visibleAfterFilters(card, wantClouds, wantProducts, wantStatus){
    const c = splitCSV(card.dataset.clouds);
    const p = splitCSV(card.dataset.products);
    const st= splitCSV(card.dataset.status);
    const cSet = new Set(c), pSet = new Set(p), sSet = new Set(st);

    // Treat "all selected" as same as "none selected"
    const allCloudVals = Array.from(document.querySelectorAll("#clouds input[type=checkbox]")).map(x=>x.value.toLowerCase());
    const allProdVals  = Array.from(document.querySelectorAll("#products input[type=checkbox]")).map(x=>x.value.toLowerCase());
    const allStatVals  = Array.from(document.querySelectorAll("#statuses input[type=checkbox]")).map(x=>x.value.toLowerCase());

    const effClouds  = (wantClouds.length  === 0 || wantClouds.length  === allCloudVals.length) ? null : new Set(wantClouds);
    const effProducts= (wantProducts.length=== 0 || wantProducts.length=== allProdVals.length) ? null : new Set(wantProducts);
    const effStatus  = (wantStatus.length === 0 || wantStatus.length === allStatVals.length)  ? null : new Set(wantStatus);

    if (effClouds){
      let hit=false;
      for (const v of effClouds){ if (cSet.has(v)) { hit=true; break; } }
      if(!hit) return false;
    }
    if (effProducts){
      let hit=false;
      for (const v of effProducts){ if (pSet.has(v)) { hit=true; break; } }
      if(!hit) return false;
    }
    if (effStatus){
      let hit=false;
      for (const v of effStatus){ if (sSet.has(v)) { hit=true; break; } }
      if(!hit) return false;
    }
    return true;
  }
  function applyFilters(){
    const wantClouds  = getCheckedVals('cloud');
    const wantProducts= getCheckedVals('product');
    const wantStatus  = getCheckedVals('status');

    const groups = document.querySelectorAll('.group');
    groups.forEach(g => {
      let visibleCount = 0;
      g.querySelectorAll('.card').forEach(card => {
        const ok = visibleAfterFilters(card, wantClouds, wantProducts, wantStatus);
        card.classList.toggle('hidden', !ok);
        if (ok) visibleCount++;
      });
      // Hide group header when no cards visible
      g.classList.toggle('hidden', visibleCount === 0);
    });
  }
  document.getElementById('apply').addEventListener('click', applyFilters);
  document.getElementById('clear').addEventListener('click', function(){
    document.querySelectorAll('.controls input[type=checkbox]').forEach(cb => cb.checked = false);
    applyFilters();
  });
  // Initial state: show everything
  applyFilters();
})();
</script>
'@
  $null = $sb.AppendLine($js)

  $sb.ToString()
}

#endregion

#region ===== Public cmdlets =====

function Get-M365Roadmap {
  [CmdletBinding()]
  param(
    [string[]]$Products,
    [string[]]$Platforms,
    [string[]]$CloudInstances,
    [string[]]$ReleasePhase,
    [string[]]$Status,
    [string]$Text,
    [Nullable[datetime]]$UpdatedSince,
    [Nullable[datetime]]$CreatedSince,

    [switch]$NextMonth,
    [switch]$GAQuarter,

    [Nullable[datetime]]$GAFrom,
    [Nullable[datetime]]$GATo,

    [ValidateSet('Cloud','Product','None')] [string]$GroupBy = 'Cloud',
    [int]$Top = 200,
    [string]$OutputPath,
    [string]$Title = 'Roadmap Briefing'
  )

  Write-Verbose 'Begin Get-M365Roadmap'

  $raw = Invoke-RestMethod -Uri 'https://www.microsoft.com/releasecommunications/api/v1/m365'
  $items = @($raw)
  if ($raw -and $raw.PSObject.Properties['features']) { $items = @($raw.features) }

  # Normalize tags onto top level so callers can rely on .products/.platforms/.clouds/.phases
  for ($i=0; $i -lt $items.Count; $i++){
    $x = $items[$i]
    $t = Get-RoadmapTags -Item $x
    foreach ($pair in @(
        @{ name='products';  value=$t.Products  },
        @{ name='platforms'; value=$t.Platforms },
        @{ name='clouds';    value=$t.Clouds    },
        @{ name='phases';    value=$t.Phases    }
      )) {
      $n = $pair.name; $v = $pair.value
      if (-not $x.PSObject.Properties[$n]) {
        Add-Member -InputObject $x -NotePropertyName $n -NotePropertyValue $v -Force
      } else {
        $x.$n = ConvertTo-StringList $x.$n
        if ($x.$n.Count -eq 0 -and $v.Count -gt 0) { $x.$n = $v }
      }
    }
    # normalize clouds/phases names
    $x.clouds = @($x.clouds | ForEach-Object { ConvertTo-CloudName $_ })
    $x.phases = @($x.phases | ForEach-Object { ConvertTo-PhaseName $_ })
    $items[$i] = $x
  }

  # GA window if requested
  $subtitle = (Get-Date).ToString('yyyy-MM-dd')
  if ($NextMonth) {
    $first = Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0
    $first = $first.AddMonths(1)
    $last  = $first.AddMonths(1).AddDays(-1)
    $GAFrom = $first
    $GATo   = if ($GAQuarter) { $first.AddMonths(3).AddDays(-1) } else { $last }
    $subtitle = ("{0}..{1} (planned months via GA text)" -f $GAFrom.ToString('M/d/yyyy'), $GATo.ToString('M/d/yyyy'))
    Write-Verbose ("GA window: {0}..{1} (planned months via GA text)" -f $GAFrom.ToShortDateString(), $GATo.ToShortDateString())
  } elseif ($GAFrom.HasValue -or $GATo.HasValue) {
    $subtitle = ("GA window: {0}..{1}" -f ($GAFrom, $GATo | ForEach-Object { if($_){ $_.ToString('M/d/yyyy') } else { '' } }) -join '')
  }

  # Build filter args, prune empties
  $filterArgs = @{
    Items          = $items
    Products       = $Products
    Platforms      = $Platforms
    CloudInstances = $CloudInstances
    ReleasePhase   = $ReleasePhase
    Status         = $Status
    Text           = $Text
    UpdatedSince   = $UpdatedSince
    CreatedSince   = $CreatedSince
    GAFrom         = $GAFrom
    GATo           = $GATo
  }
  foreach($k in @('Products','Platforms','CloudInstances','ReleasePhase','Status','Text','UpdatedSince','CreatedSince','GAFrom','GATo')) {
    if ($filterArgs.ContainsKey($k)) {
      $v = $filterArgs[$k]
      if ($null -eq $v -or ($v -is [array] -and $v.Count -eq 0) -or
          ($v -is [string] -and [string]::IsNullOrWhiteSpace($v))) {
        $null = $filterArgs.Remove($k)
      }
    }
  }

  $items = Select-RoadmapItems @filterArgs

  # sort newest first by modified/created text
  $sortable = @()
  foreach($it in $items){
    $val = $null
    if (-not [datetime]::TryParse([string]$it.modified, [ref]$val)) {
      [void][datetime]::TryParse([string]$it.created, [ref]$val)
    }
    if ($null -eq $val) { $val = Get-Date '1900-01-01' }
    $sortable += [pscustomobject]@{ _key=$val; _it=$it }
  }
  $sortable = $sortable | Sort-Object -Property _key -Descending
  $items = @($sortable | ForEach-Object { $_._it })
  if ($Top -gt 0 -and $items.Count -gt $Top) { $items = @($items | Select-Object -First $Top) }

  Write-Verbose ("Items after filter: {0}" -f $items.Count)

  $html = New-RoadmapHtml -Items $items -Title $Title -Subtitle $subtitle -GroupBy $GroupBy

  if ($OutputPath) {
    $dir = Split-Path -Parent $OutputPath
    if (-not (Test-Path $dir)) { New-Item -Path $dir -ItemType Directory | Out-Null }
    Set-Content -Path $OutputPath -Value $html -Encoding UTF8
    Write-Host "Roadmap briefing written to: $OutputPath"
    return $OutputPath
  }
  return $html
}

# stubs so export works in environments that expect these names
function Get-M365ServiceMessages { [CmdletBinding()] param() Write-Verbose "Get-M365ServiceMessages stub." }
function Connect-GraphCertificate { [CmdletBinding()] param() Write-Verbose "Connect-GraphCertificate stub." }

Export-ModuleMember -Function Get-M365Roadmap, Get-M365ServiceMessages, Connect-GraphCertificate

#endregion
